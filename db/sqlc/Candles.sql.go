// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: Candles.sql

package db

import (
	"context"
	"database/sql"
)

const deletePairs15m = `-- name: DeletePairs15m :execresult
DELETE FROM candles_15m WHERE name = ?
`

func (q *Queries) DeletePairs15m(ctx context.Context, name string) (sql.Result, error) {
	return q.db.ExecContext(ctx, deletePairs15m, name)
}

const deletePairs1d = `-- name: DeletePairs1d :execresult
DELETE FROM candles_1d WHERE name = ?
`

func (q *Queries) DeletePairs1d(ctx context.Context, name string) (sql.Result, error) {
	return q.db.ExecContext(ctx, deletePairs1d, name)
}

const deletePairs1h = `-- name: DeletePairs1h :execresult
DELETE FROM candles_1h WHERE name = ?
`

func (q *Queries) DeletePairs1h(ctx context.Context, name string) (sql.Result, error) {
	return q.db.ExecContext(ctx, deletePairs1h, name)
}

const deletePairs4h = `-- name: DeletePairs4h :execresult
DELETE FROM candles_4h WHERE name = ?
`

func (q *Queries) DeletePairs4h(ctx context.Context, name string) (sql.Result, error) {
	return q.db.ExecContext(ctx, deletePairs4h, name)
}

const deletePairs5m = `-- name: DeletePairs5m :execresult
DELETE FROM candles_5m WHERE name = ?
`

func (q *Queries) DeletePairs5m(ctx context.Context, name string) (sql.Result, error) {
	return q.db.ExecContext(ctx, deletePairs5m, name)
}

const get15mCandles = `-- name: Get15mCandles :many
SELECT name, open, close, high, low, time, volume, color FROM candles_15m 
WHERE name = ?  AND time <= ?
ORDER BY time DESC 
LIMIT ?
`

type Get15mCandlesParams struct {
	Name  string `json:"name"`
	Time  int64  `json:"time"`
	Limit int32  `json:"limit"`
}

func (q *Queries) Get15mCandles(ctx context.Context, arg Get15mCandlesParams) ([]Candles15m, error) {
	rows, err := q.db.QueryContext(ctx, get15mCandles, arg.Name, arg.Time, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Candles15m{}
	for rows.Next() {
		var i Candles15m
		if err := rows.Scan(
			&i.Name,
			&i.Open,
			&i.Close,
			&i.High,
			&i.Low,
			&i.Time,
			&i.Volume,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const get15mCandlesRnage = `-- name: Get15mCandlesRnage :many
SELECT name, open, close, high, low, time, volume, color FROM candles_15m 
WHERE name = ? AND time > ? AND time <= ?
ORDER BY time DESC
`

type Get15mCandlesRnageParams struct {
	Name   string `json:"name"`
	Time   int64  `json:"time"`
	Time_2 int64  `json:"time_2"`
}

func (q *Queries) Get15mCandlesRnage(ctx context.Context, arg Get15mCandlesRnageParams) ([]Candles15m, error) {
	rows, err := q.db.QueryContext(ctx, get15mCandlesRnage, arg.Name, arg.Time, arg.Time_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Candles15m{}
	for rows.Next() {
		var i Candles15m
		if err := rows.Scan(
			&i.Name,
			&i.Open,
			&i.Close,
			&i.High,
			&i.Low,
			&i.Time,
			&i.Volume,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const get15mMinMaxTime = `-- name: Get15mMinMaxTime :one
SELECT MIN(time), MAX(time)
FROM candles_15m
WHERE name = ?
`

type Get15mMinMaxTimeRow struct {
	Min interface{} `json:"min"`
	Max interface{} `json:"max"`
}

func (q *Queries) Get15mMinMaxTime(ctx context.Context, name string) (Get15mMinMaxTimeRow, error) {
	row := q.db.QueryRowContext(ctx, get15mMinMaxTime, name)
	var i Get15mMinMaxTimeRow
	err := row.Scan(&i.Min, &i.Max)
	return i, err
}

const get15mResult = `-- name: Get15mResult :many
SELECT name, open, close, high, low, time, volume, color FROM candles_15m 
WHERE name = ? AND time > ?
ORDER BY time ASC 
LIMIT ?
`

type Get15mResultParams struct {
	Name  string `json:"name"`
	Time  int64  `json:"time"`
	Limit int32  `json:"limit"`
}

func (q *Queries) Get15mResult(ctx context.Context, arg Get15mResultParams) ([]Candles15m, error) {
	rows, err := q.db.QueryContext(ctx, get15mResult, arg.Name, arg.Time, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Candles15m{}
	for rows.Next() {
		var i Candles15m
		if err := rows.Scan(
			&i.Name,
			&i.Open,
			&i.Close,
			&i.High,
			&i.Low,
			&i.Time,
			&i.Volume,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const get15mVolSumPriceAVG = `-- name: Get15mVolSumPriceAVG :one
SELECT SUM(volume) AS volsum, AVG(close) AS priceavg FROM candles_15m WHERE name = ? AND time <= ?
`

type Get15mVolSumPriceAVGParams struct {
	Name string `json:"name"`
	Time int64  `json:"time"`
}

type Get15mVolSumPriceAVGRow struct {
	Volsum   interface{} `json:"volsum"`
	Priceavg interface{} `json:"priceavg"`
}

func (q *Queries) Get15mVolSumPriceAVG(ctx context.Context, arg Get15mVolSumPriceAVGParams) (Get15mVolSumPriceAVGRow, error) {
	row := q.db.QueryRowContext(ctx, get15mVolSumPriceAVG, arg.Name, arg.Time)
	var i Get15mVolSumPriceAVGRow
	err := row.Scan(&i.Volsum, &i.Priceavg)
	return i, err
}

const get1dCandles = `-- name: Get1dCandles :many
SELECT name, open, close, high, low, time, volume, color FROM candles_1d 
WHERE name = ? AND time <= ?
ORDER BY time DESC 
LIMIT ?
`

type Get1dCandlesParams struct {
	Name  string `json:"name"`
	Time  int64  `json:"time"`
	Limit int32  `json:"limit"`
}

func (q *Queries) Get1dCandles(ctx context.Context, arg Get1dCandlesParams) ([]Candles1d, error) {
	rows, err := q.db.QueryContext(ctx, get1dCandles, arg.Name, arg.Time, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Candles1d{}
	for rows.Next() {
		var i Candles1d
		if err := rows.Scan(
			&i.Name,
			&i.Open,
			&i.Close,
			&i.High,
			&i.Low,
			&i.Time,
			&i.Volume,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const get1dCandlesRnage = `-- name: Get1dCandlesRnage :many
SELECT name, open, close, high, low, time, volume, color FROM candles_1d 
WHERE name = ? AND time > ? AND time <= ?
ORDER BY time DESC
`

type Get1dCandlesRnageParams struct {
	Name   string `json:"name"`
	Time   int64  `json:"time"`
	Time_2 int64  `json:"time_2"`
}

func (q *Queries) Get1dCandlesRnage(ctx context.Context, arg Get1dCandlesRnageParams) ([]Candles1d, error) {
	rows, err := q.db.QueryContext(ctx, get1dCandlesRnage, arg.Name, arg.Time, arg.Time_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Candles1d{}
	for rows.Next() {
		var i Candles1d
		if err := rows.Scan(
			&i.Name,
			&i.Open,
			&i.Close,
			&i.High,
			&i.Low,
			&i.Time,
			&i.Volume,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const get1dMinMaxTime = `-- name: Get1dMinMaxTime :one
SELECT MIN(time), MAX(time)
FROM candles_1d
WHERE name = ?
`

type Get1dMinMaxTimeRow struct {
	Min interface{} `json:"min"`
	Max interface{} `json:"max"`
}

func (q *Queries) Get1dMinMaxTime(ctx context.Context, name string) (Get1dMinMaxTimeRow, error) {
	row := q.db.QueryRowContext(ctx, get1dMinMaxTime, name)
	var i Get1dMinMaxTimeRow
	err := row.Scan(&i.Min, &i.Max)
	return i, err
}

const get1dResult = `-- name: Get1dResult :many
SELECT name, open, close, high, low, time, volume, color FROM candles_1d 
WHERE name = ? AND time > ?
ORDER BY time ASC 
LIMIT ?
`

type Get1dResultParams struct {
	Name  string `json:"name"`
	Time  int64  `json:"time"`
	Limit int32  `json:"limit"`
}

func (q *Queries) Get1dResult(ctx context.Context, arg Get1dResultParams) ([]Candles1d, error) {
	rows, err := q.db.QueryContext(ctx, get1dResult, arg.Name, arg.Time, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Candles1d{}
	for rows.Next() {
		var i Candles1d
		if err := rows.Scan(
			&i.Name,
			&i.Open,
			&i.Close,
			&i.High,
			&i.Low,
			&i.Time,
			&i.Volume,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const get1dVolSumPriceAVG = `-- name: Get1dVolSumPriceAVG :one
SELECT SUM(volume) AS volsum, AVG(close) AS priceavg FROM candles_1d WHERE name = ? AND time <= ?
`

type Get1dVolSumPriceAVGParams struct {
	Name string `json:"name"`
	Time int64  `json:"time"`
}

type Get1dVolSumPriceAVGRow struct {
	Volsum   interface{} `json:"volsum"`
	Priceavg interface{} `json:"priceavg"`
}

func (q *Queries) Get1dVolSumPriceAVG(ctx context.Context, arg Get1dVolSumPriceAVGParams) (Get1dVolSumPriceAVGRow, error) {
	row := q.db.QueryRowContext(ctx, get1dVolSumPriceAVG, arg.Name, arg.Time)
	var i Get1dVolSumPriceAVGRow
	err := row.Scan(&i.Volsum, &i.Priceavg)
	return i, err
}

const get1hCandles = `-- name: Get1hCandles :many
SELECT name, open, close, high, low, time, volume, color FROM candles_1h 
WHERE name = ?  AND time <= ?
ORDER BY time DESC 
LIMIT ?
`

type Get1hCandlesParams struct {
	Name  string `json:"name"`
	Time  int64  `json:"time"`
	Limit int32  `json:"limit"`
}

func (q *Queries) Get1hCandles(ctx context.Context, arg Get1hCandlesParams) ([]Candles1h, error) {
	rows, err := q.db.QueryContext(ctx, get1hCandles, arg.Name, arg.Time, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Candles1h{}
	for rows.Next() {
		var i Candles1h
		if err := rows.Scan(
			&i.Name,
			&i.Open,
			&i.Close,
			&i.High,
			&i.Low,
			&i.Time,
			&i.Volume,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const get1hCandlesRnage = `-- name: Get1hCandlesRnage :many
SELECT name, open, close, high, low, time, volume, color FROM candles_1h 
WHERE name = ? AND time > ? AND time <= ?
ORDER BY time DESC
`

type Get1hCandlesRnageParams struct {
	Name   string `json:"name"`
	Time   int64  `json:"time"`
	Time_2 int64  `json:"time_2"`
}

func (q *Queries) Get1hCandlesRnage(ctx context.Context, arg Get1hCandlesRnageParams) ([]Candles1h, error) {
	rows, err := q.db.QueryContext(ctx, get1hCandlesRnage, arg.Name, arg.Time, arg.Time_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Candles1h{}
	for rows.Next() {
		var i Candles1h
		if err := rows.Scan(
			&i.Name,
			&i.Open,
			&i.Close,
			&i.High,
			&i.Low,
			&i.Time,
			&i.Volume,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const get1hEntryTimestamp = `-- name: Get1hEntryTimestamp :one
SELECT time FROM candles_1h 
WHERE name = ?  AND time <= ?
ORDER BY time desc 
LIMIT 1
`

type Get1hEntryTimestampParams struct {
	Name string `json:"name"`
	Time int64  `json:"time"`
}

func (q *Queries) Get1hEntryTimestamp(ctx context.Context, arg Get1hEntryTimestampParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, get1hEntryTimestamp, arg.Name, arg.Time)
	var time int64
	err := row.Scan(&time)
	return time, err
}

const get1hMinMaxTime = `-- name: Get1hMinMaxTime :one
SELECT MIN(time), MAX(time)
FROM candles_1h
WHERE name = ?
`

type Get1hMinMaxTimeRow struct {
	Min interface{} `json:"min"`
	Max interface{} `json:"max"`
}

func (q *Queries) Get1hMinMaxTime(ctx context.Context, name string) (Get1hMinMaxTimeRow, error) {
	row := q.db.QueryRowContext(ctx, get1hMinMaxTime, name)
	var i Get1hMinMaxTimeRow
	err := row.Scan(&i.Min, &i.Max)
	return i, err
}

const get1hResult = `-- name: Get1hResult :many
SELECT name, open, close, high, low, time, volume, color FROM candles_1h 
WHERE name = ? AND time > ?
ORDER BY time ASC 
LIMIT ?
`

type Get1hResultParams struct {
	Name  string `json:"name"`
	Time  int64  `json:"time"`
	Limit int32  `json:"limit"`
}

func (q *Queries) Get1hResult(ctx context.Context, arg Get1hResultParams) ([]Candles1h, error) {
	rows, err := q.db.QueryContext(ctx, get1hResult, arg.Name, arg.Time, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Candles1h{}
	for rows.Next() {
		var i Candles1h
		if err := rows.Scan(
			&i.Name,
			&i.Open,
			&i.Close,
			&i.High,
			&i.Low,
			&i.Time,
			&i.Volume,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const get1hVolSumPriceAVG = `-- name: Get1hVolSumPriceAVG :one
SELECT SUM(volume) AS volsum, AVG(close) AS priceavg FROM candles_1h WHERE name = ? AND time <= ?
`

type Get1hVolSumPriceAVGParams struct {
	Name string `json:"name"`
	Time int64  `json:"time"`
}

type Get1hVolSumPriceAVGRow struct {
	Volsum   interface{} `json:"volsum"`
	Priceavg interface{} `json:"priceavg"`
}

func (q *Queries) Get1hVolSumPriceAVG(ctx context.Context, arg Get1hVolSumPriceAVGParams) (Get1hVolSumPriceAVGRow, error) {
	row := q.db.QueryRowContext(ctx, get1hVolSumPriceAVG, arg.Name, arg.Time)
	var i Get1hVolSumPriceAVGRow
	err := row.Scan(&i.Volsum, &i.Priceavg)
	return i, err
}

const get4hCandles = `-- name: Get4hCandles :many
SELECT name, open, close, high, low, time, volume, color FROM candles_4h 
WHERE name = ?  AND time <= ?
ORDER BY time DESC 
LIMIT ?
`

type Get4hCandlesParams struct {
	Name  string `json:"name"`
	Time  int64  `json:"time"`
	Limit int32  `json:"limit"`
}

func (q *Queries) Get4hCandles(ctx context.Context, arg Get4hCandlesParams) ([]Candles4h, error) {
	rows, err := q.db.QueryContext(ctx, get4hCandles, arg.Name, arg.Time, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Candles4h{}
	for rows.Next() {
		var i Candles4h
		if err := rows.Scan(
			&i.Name,
			&i.Open,
			&i.Close,
			&i.High,
			&i.Low,
			&i.Time,
			&i.Volume,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const get4hCandlesRnage = `-- name: Get4hCandlesRnage :many
SELECT name, open, close, high, low, time, volume, color FROM candles_4h 
WHERE name = ? AND time > ? AND time <= ?
ORDER BY time DESC
`

type Get4hCandlesRnageParams struct {
	Name   string `json:"name"`
	Time   int64  `json:"time"`
	Time_2 int64  `json:"time_2"`
}

func (q *Queries) Get4hCandlesRnage(ctx context.Context, arg Get4hCandlesRnageParams) ([]Candles4h, error) {
	rows, err := q.db.QueryContext(ctx, get4hCandlesRnage, arg.Name, arg.Time, arg.Time_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Candles4h{}
	for rows.Next() {
		var i Candles4h
		if err := rows.Scan(
			&i.Name,
			&i.Open,
			&i.Close,
			&i.High,
			&i.Low,
			&i.Time,
			&i.Volume,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const get4hMinMaxTime = `-- name: Get4hMinMaxTime :one
SELECT MIN(time), MAX(time)
FROM candles_4h
WHERE name = ?
`

type Get4hMinMaxTimeRow struct {
	Min interface{} `json:"min"`
	Max interface{} `json:"max"`
}

func (q *Queries) Get4hMinMaxTime(ctx context.Context, name string) (Get4hMinMaxTimeRow, error) {
	row := q.db.QueryRowContext(ctx, get4hMinMaxTime, name)
	var i Get4hMinMaxTimeRow
	err := row.Scan(&i.Min, &i.Max)
	return i, err
}

const get4hResult = `-- name: Get4hResult :many
SELECT name, open, close, high, low, time, volume, color FROM candles_4h 
WHERE name = ? AND time > ?
ORDER BY time ASC 
LIMIT ?
`

type Get4hResultParams struct {
	Name  string `json:"name"`
	Time  int64  `json:"time"`
	Limit int32  `json:"limit"`
}

func (q *Queries) Get4hResult(ctx context.Context, arg Get4hResultParams) ([]Candles4h, error) {
	rows, err := q.db.QueryContext(ctx, get4hResult, arg.Name, arg.Time, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Candles4h{}
	for rows.Next() {
		var i Candles4h
		if err := rows.Scan(
			&i.Name,
			&i.Open,
			&i.Close,
			&i.High,
			&i.Low,
			&i.Time,
			&i.Volume,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const get4hVolSumPriceAVG = `-- name: Get4hVolSumPriceAVG :one
SELECT SUM(volume) AS volsum, AVG(close) AS priceavg FROM candles_4h WHERE name = ? AND time <= ?
`

type Get4hVolSumPriceAVGParams struct {
	Name string `json:"name"`
	Time int64  `json:"time"`
}

type Get4hVolSumPriceAVGRow struct {
	Volsum   interface{} `json:"volsum"`
	Priceavg interface{} `json:"priceavg"`
}

func (q *Queries) Get4hVolSumPriceAVG(ctx context.Context, arg Get4hVolSumPriceAVGParams) (Get4hVolSumPriceAVGRow, error) {
	row := q.db.QueryRowContext(ctx, get4hVolSumPriceAVG, arg.Name, arg.Time)
	var i Get4hVolSumPriceAVGRow
	err := row.Scan(&i.Volsum, &i.Priceavg)
	return i, err
}

const get5mCandles = `-- name: Get5mCandles :many
SELECT name, open, close, high, low, time, volume, color FROM candles_5m 
WHERE name = ?  AND time <= ?
ORDER BY time DESC 
LIMIT ?
`

type Get5mCandlesParams struct {
	Name  string `json:"name"`
	Time  int64  `json:"time"`
	Limit int32  `json:"limit"`
}

func (q *Queries) Get5mCandles(ctx context.Context, arg Get5mCandlesParams) ([]Candles5m, error) {
	rows, err := q.db.QueryContext(ctx, get5mCandles, arg.Name, arg.Time, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Candles5m{}
	for rows.Next() {
		var i Candles5m
		if err := rows.Scan(
			&i.Name,
			&i.Open,
			&i.Close,
			&i.High,
			&i.Low,
			&i.Time,
			&i.Volume,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const get5mCandlesRnage = `-- name: Get5mCandlesRnage :many
SELECT name, open, close, high, low, time, volume, color FROM candles_5m 
WHERE name = ? AND time > ? AND time <= ?
ORDER BY time DESC
`

type Get5mCandlesRnageParams struct {
	Name   string `json:"name"`
	Time   int64  `json:"time"`
	Time_2 int64  `json:"time_2"`
}

func (q *Queries) Get5mCandlesRnage(ctx context.Context, arg Get5mCandlesRnageParams) ([]Candles5m, error) {
	rows, err := q.db.QueryContext(ctx, get5mCandlesRnage, arg.Name, arg.Time, arg.Time_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Candles5m{}
	for rows.Next() {
		var i Candles5m
		if err := rows.Scan(
			&i.Name,
			&i.Open,
			&i.Close,
			&i.High,
			&i.Low,
			&i.Time,
			&i.Volume,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const get5mMinMaxTime = `-- name: Get5mMinMaxTime :one
SELECT MIN(time), MAX(time)
FROM candles_5m
WHERE name = ?
`

type Get5mMinMaxTimeRow struct {
	Min interface{} `json:"min"`
	Max interface{} `json:"max"`
}

func (q *Queries) Get5mMinMaxTime(ctx context.Context, name string) (Get5mMinMaxTimeRow, error) {
	row := q.db.QueryRowContext(ctx, get5mMinMaxTime, name)
	var i Get5mMinMaxTimeRow
	err := row.Scan(&i.Min, &i.Max)
	return i, err
}

const get5mResult = `-- name: Get5mResult :many
SELECT name, open, close, high, low, time, volume, color FROM candles_5m 
WHERE name = ? AND time > ?
ORDER BY time ASC 
LIMIT ?
`

type Get5mResultParams struct {
	Name  string `json:"name"`
	Time  int64  `json:"time"`
	Limit int32  `json:"limit"`
}

func (q *Queries) Get5mResult(ctx context.Context, arg Get5mResultParams) ([]Candles5m, error) {
	rows, err := q.db.QueryContext(ctx, get5mResult, arg.Name, arg.Time, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Candles5m{}
	for rows.Next() {
		var i Candles5m
		if err := rows.Scan(
			&i.Name,
			&i.Open,
			&i.Close,
			&i.High,
			&i.Low,
			&i.Time,
			&i.Volume,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const get5mVolSumPriceAVG = `-- name: Get5mVolSumPriceAVG :one
SELECT SUM(volume) AS volsum, AVG(close) AS priceavg FROM candles_5m WHERE name = ? AND time <= ?
`

type Get5mVolSumPriceAVGParams struct {
	Name string `json:"name"`
	Time int64  `json:"time"`
}

type Get5mVolSumPriceAVGRow struct {
	Volsum   interface{} `json:"volsum"`
	Priceavg interface{} `json:"priceavg"`
}

func (q *Queries) Get5mVolSumPriceAVG(ctx context.Context, arg Get5mVolSumPriceAVGParams) (Get5mVolSumPriceAVGRow, error) {
	row := q.db.QueryRowContext(ctx, get5mVolSumPriceAVG, arg.Name, arg.Time)
	var i Get5mVolSumPriceAVGRow
	err := row.Scan(&i.Volsum, &i.Priceavg)
	return i, err
}

const getAllPairsInDB1D = `-- name: GetAllPairsInDB1D :many
SELECT DISTINCT name from candles_1d
ORDER BY name
`

func (q *Queries) GetAllPairsInDB1D(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getAllPairsInDB1D)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPairsInDB1H = `-- name: GetAllPairsInDB1H :many

SELECT DISTINCT name from candles_1h
ORDER BY name
`

// --------utils----------------
func (q *Queries) GetAllPairsInDB1H(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getAllPairsInDB1H)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnder1YPairs = `-- name: GetUnder1YPairs :many
SELECT name
FROM candles_1d
GROUP BY name
HAVING COUNT(name) < ?
`

func (q *Queries) GetUnder1YPairs(ctx context.Context, name string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getUnder1YPairs, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insert15mCandles = `-- name: Insert15mCandles :execresult
INSERT INTO candles_15m (
    name,
    open,
    close,
    high,
    low,
    time,
    volume,
    color
) VALUES (
  ?,?,?,?,?,?,?,?
)
`

type Insert15mCandlesParams struct {
	Name   string  `json:"name"`
	Open   float64 `json:"open"`
	Close  float64 `json:"close"`
	High   float64 `json:"high"`
	Low    float64 `json:"low"`
	Time   int64   `json:"time"`
	Volume float64 `json:"volume"`
	Color  string  `json:"color"`
}

func (q *Queries) Insert15mCandles(ctx context.Context, arg Insert15mCandlesParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insert15mCandles,
		arg.Name,
		arg.Open,
		arg.Close,
		arg.High,
		arg.Low,
		arg.Time,
		arg.Volume,
		arg.Color,
	)
}

const insert1dCandles = `-- name: Insert1dCandles :execresult
INSERT INTO candles_1d (
    name,
    open,
    close,
    high,
    low,
    time,
    volume,
    color
) VALUES (
  ?,?,?,?,?,?,?,?
)
`

type Insert1dCandlesParams struct {
	Name   string  `json:"name"`
	Open   float64 `json:"open"`
	Close  float64 `json:"close"`
	High   float64 `json:"high"`
	Low    float64 `json:"low"`
	Time   int64   `json:"time"`
	Volume float64 `json:"volume"`
	Color  string  `json:"color"`
}

func (q *Queries) Insert1dCandles(ctx context.Context, arg Insert1dCandlesParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insert1dCandles,
		arg.Name,
		arg.Open,
		arg.Close,
		arg.High,
		arg.Low,
		arg.Time,
		arg.Volume,
		arg.Color,
	)
}

const insert1hCandles = `-- name: Insert1hCandles :execresult
INSERT INTO candles_1h (
    name,
    open,
    close,
    high,
    low,
    time,
    volume,
    color
) VALUES (
  ?,?,?,?,?,?,?,?
)
`

type Insert1hCandlesParams struct {
	Name   string  `json:"name"`
	Open   float64 `json:"open"`
	Close  float64 `json:"close"`
	High   float64 `json:"high"`
	Low    float64 `json:"low"`
	Time   int64   `json:"time"`
	Volume float64 `json:"volume"`
	Color  string  `json:"color"`
}

func (q *Queries) Insert1hCandles(ctx context.Context, arg Insert1hCandlesParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insert1hCandles,
		arg.Name,
		arg.Open,
		arg.Close,
		arg.High,
		arg.Low,
		arg.Time,
		arg.Volume,
		arg.Color,
	)
}

const insert4hCandles = `-- name: Insert4hCandles :execresult
INSERT INTO candles_4h (
    name,
    open,
    close,
    high,
    low,
    time,
    volume,
    color
) VALUES (
  ?,?,?,?,?,?,?,?
)
`

type Insert4hCandlesParams struct {
	Name   string  `json:"name"`
	Open   float64 `json:"open"`
	Close  float64 `json:"close"`
	High   float64 `json:"high"`
	Low    float64 `json:"low"`
	Time   int64   `json:"time"`
	Volume float64 `json:"volume"`
	Color  string  `json:"color"`
}

func (q *Queries) Insert4hCandles(ctx context.Context, arg Insert4hCandlesParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insert4hCandles,
		arg.Name,
		arg.Open,
		arg.Close,
		arg.High,
		arg.Low,
		arg.Time,
		arg.Volume,
		arg.Color,
	)
}

const insert5mCandles = `-- name: Insert5mCandles :execresult
INSERT INTO candles_5m (
    name,
    open,
    close,
    high,
    low,
    time,
    volume,
    color
) VALUES (
  ?,?,?,?,?,?,?,?
)
`

type Insert5mCandlesParams struct {
	Name   string  `json:"name"`
	Open   float64 `json:"open"`
	Close  float64 `json:"close"`
	High   float64 `json:"high"`
	Low    float64 `json:"low"`
	Time   int64   `json:"time"`
	Volume float64 `json:"volume"`
	Color  string  `json:"color"`
}

func (q *Queries) Insert5mCandles(ctx context.Context, arg Insert5mCandlesParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insert5mCandles,
		arg.Name,
		arg.Open,
		arg.Close,
		arg.High,
		arg.Low,
		arg.Time,
		arg.Volume,
		arg.Color,
	)
}
